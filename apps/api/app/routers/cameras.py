import logging
from typing import List, Dict

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from ..core.database import get_db_session, db
from ..core.security import get_current_user, get_current_user_for_stream
from ..models.database import Camera
from ..schemas import CameraCreate, CameraResponse, WebcamInfo
from ..services.camera_streaming_service import streaming_service
from ..services.camera_diagnostics import camera_diagnostics

router = APIRouter(prefix="/v1", tags=["Camera Management"])
logger = logging.getLogger(__name__)


@router.get("/sites/{site_id}/cameras", response_model=List[CameraResponse])
async def list_cameras(
    site_id: str,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(Camera.tenant_id == user["tenant_id"], Camera.site_id == site_id)
        )
    )
    cameras = result.scalars().all()
    return cameras


@router.post("/sites/{site_id}/cameras", response_model=CameraResponse)
async def create_camera(
    site_id: str,
    camera: CameraCreate,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    # Validate camera configuration
    if camera.camera_type.value == "webcam":
        if camera.device_index is None:
            raise HTTPException(status_code=400, detail="device_index is required for webcam cameras")
        if camera.device_index < 0:
            raise HTTPException(status_code=400, detail="device_index must be non-negative")
        
        # Check if device_index is already in use by another camera in this tenant/site
        existing_camera_result = await db_session.execute(
            select(Camera).where(
                and_(
                    Camera.tenant_id == user["tenant_id"],
                    Camera.site_id == site_id,
                    Camera.camera_type == camera.camera_type,
                    Camera.device_index == camera.device_index
                )
            )
        )
        existing_camera = existing_camera_result.scalar_one_or_none()
        if existing_camera:
            raise HTTPException(
                status_code=400, 
                detail=f"Device index {camera.device_index} is already used by camera {existing_camera.camera_id}"
            )
    
    elif camera.camera_type.value == "rtsp":
        if not camera.rtsp_url:
            raise HTTPException(status_code=400, detail="rtsp_url is required for RTSP cameras")
        if camera.device_index is not None:
            raise HTTPException(status_code=400, detail="device_index should not be set for RTSP cameras")
    
    # camera_id will be auto-generated by the database (auto-increment bigint)
    new_camera = Camera(
        tenant_id=user["tenant_id"],
        site_id=site_id,
        name=camera.name,
        camera_type=camera.camera_type,
        rtsp_url=camera.rtsp_url,
        device_index=camera.device_index
    )
    db_session.add(new_camera)
    await db_session.commit()
    await db_session.refresh(new_camera)  # Get the auto-generated camera_id
    return new_camera


@router.get("/sites/{site_id}/cameras/{camera_id:int}", response_model=CameraResponse)
async def get_camera(
    site_id: str,
    camera_id: int,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    return camera


@router.put("/sites/{site_id}/cameras/{camera_id:int}", response_model=CameraResponse)
async def update_camera(
    site_id: str,
    camera_id: int,
    camera_update: CameraCreate,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Update camera fields
    camera.name = camera_update.name
    camera.camera_type = camera_update.camera_type
    camera.rtsp_url = camera_update.rtsp_url
    camera.device_index = camera_update.device_index
    
    await db_session.commit()
    await db_session.refresh(camera)
    return camera


@router.delete("/sites/{site_id}/cameras/{camera_id:int}")
async def delete_camera(
    site_id: str,
    camera_id: int,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Stop all running jobs for this camera before deletion
    logger.info(f"Stopping all jobs for camera {camera_id} before deletion")
    
    camera_id_str = str(camera_id)
    stopped_services = []
    
    # 1. Stop camera streaming if active
    if streaming_service.is_stream_active(camera_id_str):
        logger.info(f"Stopping active stream for camera {camera_id}")
        success = streaming_service.stop_stream(camera_id_str)
        if success:
            stopped_services.append("camera_streaming")
        else:
            logger.warning(f"Failed to stop stream for camera {camera_id}")
    
    # 2. Clean up device locks for webcam cameras
    device_status = streaming_service.get_device_status()
    device_locks = device_status.get("device_locks", {})
    for device_index, locked_camera in device_locks.items():
        if str(locked_camera) == camera_id_str:
            streaming_service.device_locks.pop(device_index, None)
            stopped_services.append(f"device_lock_{device_index}")
            logger.info(f"Cleaned up device lock {device_index} for camera {camera_id}")
    
    # 3. Future: Notify worker processes to stop processing this camera
    # When workers support dynamic camera management, this would send
    # a stop signal to any worker processes handling this camera:
    # await worker_coordinator.stop_camera_processing(camera_id_str)
    
    # 4. Future: Stop any background face recognition jobs
    # When background face recognition jobs are implemented:
    # await face_job_manager.stop_camera_jobs(camera_id_str)
    
    # Log any services that were stopped
    if stopped_services:
        logger.info(f"Stopped services for camera {camera_id}: {stopped_services}")
    
    # Now safe to delete the camera from database
    await db_session.delete(camera)
    await db_session.commit()
    
    response = {
        "message": "Camera deleted successfully", 
        "camera_id": camera_id
    }
    if stopped_services:
        response["stopped_services"] = stopped_services
        logger.info(f"Camera {camera_id} deleted after stopping services: {stopped_services}")
    
    return response


# Camera Streaming Endpoints

@router.post("/sites/{site_id}/cameras/{camera_id:int}/stream/start")
async def start_camera_stream(
    site_id: str,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Start streaming for a specific camera"""
    tenant_id = user["tenant_id"]
    
    # Debug logging
    logger.info(f"Starting camera stream - tenant_id: {tenant_id} (type: {type(tenant_id)}), site_id: {site_id} (type: {type(site_id)}), camera_id: {camera_id} (type: {type(camera_id)})")
    
    if not tenant_id:
        raise HTTPException(status_code=400, detail="Invalid tenant_id from token")
    
    await db.set_tenant_context(db_session, str(tenant_id))
    
    # Get camera info
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    if not camera.is_active:
        raise HTTPException(status_code=400, detail="Camera is not active")
    
    # Start streaming
    success = streaming_service.start_stream(
        camera_id=str(camera_id),
        camera_type=camera.camera_type.value,
        rtsp_url=camera.rtsp_url,
        device_index=camera.device_index
    )
    
    if not success:
        raise HTTPException(status_code=500, detail="Failed to start camera stream")
    
    return {
        "message": "Camera stream started successfully",
        "camera_id": camera_id,
        "stream_active": True
    }


@router.post("/sites/{site_id}/cameras/{camera_id:int}/stream/stop")
async def stop_camera_stream(
    site_id: str,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Stop streaming for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Stop streaming
    streaming_service.stop_stream(str(camera_id))
    
    return {
        "message": "Camera stream stopped successfully",
        "camera_id": camera_id,
        "stream_active": False
    }


@router.get("/sites/{site_id}/cameras/{camera_id:int}/stream/status")
async def get_camera_stream_status(
    site_id: str,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Get streaming status for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Get stream info
    stream_info = streaming_service.get_stream_info(str(camera_id))
    is_active = streaming_service.is_stream_active(str(camera_id))
    
    return {
        "camera_id": camera_id,
        "stream_active": is_active,
        "stream_info": stream_info
    }


@router.get("/sites/{site_id}/cameras/{camera_id:int}/stream/feed")
async def get_camera_stream_feed(
    site_id: str,
    camera_id: int,
    user: Dict = Depends(get_current_user_for_stream),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Get live video feed for a camera (MJPEG stream)"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Check if stream is active
    if not streaming_service.is_stream_active(str(camera_id)):
        raise HTTPException(status_code=404, detail="Camera stream is not active")
    
    return StreamingResponse(
        streaming_service.stream_frames(str(camera_id)),
        media_type="multipart/x-mixed-replace; boundary=frame"
    )


@router.get("/streaming/debug")
async def get_streaming_debug_info(
    user: Dict = Depends(get_current_user)
):
    """Get debug information about camera streaming service"""
    device_status = streaming_service.get_device_status()
    conflicts = streaming_service.diagnose_device_conflicts()
    return {
        "streaming_service_status": device_status,
        "conflict_analysis": conflicts,
        "message": "This endpoint helps debug camera streaming conflicts and device usage"
    }


@router.post("/streaming/cleanup")
async def cleanup_all_streams(
    user: Dict = Depends(get_current_user)
):
    """Force cleanup all streams and device locks (emergency use)"""
    streaming_service.cleanup_all_streams()
    return {
        "message": "All streams and device locks have been cleaned up"
    }

@router.post("/cameras/{camera_id:int}/stop-all-jobs")
async def stop_all_camera_jobs(
    camera_id: int,
    user: Dict = Depends(get_current_user)
):
    """Stop all running jobs (streaming, face recognition, etc.) for a specific camera"""
    camera_id_str = str(camera_id)
    stopped_services = []
    
    # Stop camera streaming
    if streaming_service.is_stream_active(camera_id_str):
        logger.info(f"Stopping stream for camera {camera_id}")
        success = streaming_service.stop_stream(camera_id_str)
        if success:
            stopped_services.append("camera_streaming")
    
    # Future: Stop face recognition workers
    # This endpoint can be extended to notify worker processes
    # that they should stop processing this camera
    
    # Clean up device locks
    device_status = streaming_service.get_device_status()
    device_locks = device_status.get("device_locks", {})
    for device_index, locked_camera in device_locks.items():
        if str(locked_camera) == camera_id_str:
            streaming_service.device_locks.pop(device_index, None)
            stopped_services.append(f"device_lock_{device_index}")
            logger.info(f"Cleaned up device lock {device_index} for camera {camera_id}")
    
    return {
        "message": f"Stopped all jobs for camera {camera_id}",
        "camera_id": camera_id,
        "stopped_services": stopped_services
    }


@router.get("/streaming/validate-devices")
async def validate_device_consistency(
    user: Dict = Depends(get_current_user)
):
    """Validate consistency between database camera device_index and actual OpenCV devices"""
    # Get all webcam cameras from all sites for this tenant
    db_session = next(get_db_session())
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.camera_type == "webcam"
            )
        )
    )
    webcam_cameras = result.scalars().all()
    
    # Get available OpenCV devices
    available_devices = camera_diagnostics.enumerate_cameras()
    
    # Cross-reference
    validation_report = {
        "camera_device_mappings": [],
        "issues": [],
        "available_opencv_devices": list(available_devices.keys()),
        "cameras_using_invalid_devices": []
    }
    
    for camera in webcam_cameras:
        mapping = {
            "camera_id": camera.camera_id,
            "camera_name": camera.name,
            "site_id": camera.site_id,
            "device_index": camera.device_index,
            "device_available": camera.device_index in available_devices,
            "device_working": available_devices.get(camera.device_index, {}).get("is_working", False) if camera.device_index in available_devices else False
        }
        validation_report["camera_device_mappings"].append(mapping)
        
        if camera.device_index not in available_devices:
            validation_report["issues"].append(f"Camera {camera.camera_id} ({camera.name}) uses device_index {camera.device_index} which is not available in OpenCV enumeration")
            validation_report["cameras_using_invalid_devices"].append({
                "camera_id": camera.camera_id,
                "device_index": camera.device_index,
                "issue": "Device not found"
            })
        elif not available_devices[camera.device_index].get("is_working", False):
            validation_report["issues"].append(f"Camera {camera.camera_id} ({camera.name}) uses device_index {camera.device_index} which exists but is not working")
            validation_report["cameras_using_invalid_devices"].append({
                "camera_id": camera.camera_id,
                "device_index": camera.device_index,
                "issue": "Device not working"
            })
    
    # Check for duplicate device_index usage
    device_usage = {}
    for camera in webcam_cameras:
        if camera.device_index in device_usage:
            validation_report["issues"].append(f"Device index {camera.device_index} is used by multiple cameras: {device_usage[camera.device_index]} and {camera.camera_id}")
        else:
            device_usage[camera.device_index] = camera.camera_id
    
    validation_report["summary"] = {
        "total_webcam_cameras": len(webcam_cameras),
        "total_opencv_devices": len(available_devices),
        "working_opencv_devices": len([d for d in available_devices.values() if d.get("is_working", False)]),
        "cameras_with_issues": len(validation_report["cameras_using_invalid_devices"]),
        "total_issues": len(validation_report["issues"])
    }
    
    return validation_report


@router.get("/diagnostics/cameras")
async def run_camera_diagnostics(
    user: Dict = Depends(get_current_user)
):
    """Run comprehensive camera diagnostic tests"""
    report = camera_diagnostics.generate_full_report()
    return {
        "diagnostic_report": report,
        "message": "This endpoint tests camera enumeration and simultaneous access capabilities"
    }


@router.get("/devices/webcams", response_model=List[WebcamInfo])
async def list_available_webcams(
    user: Dict = Depends(get_current_user)
):
    """List available webcam devices on the API host with basic info and whether currently in use by streaming service."""
    # Enumerate devices using diagnostics helper
    devices = camera_diagnostics.enumerate_cameras()
    # Overlay current usage from streaming service
    device_status = streaming_service.get_device_status()
    device_locks: Dict[int, str] = device_status.get("device_locks", {}) if isinstance(device_status, dict) else {}

    webcams: List[WebcamInfo] = []
    for device_index, info in devices.items():
        webcams.append(WebcamInfo(
            device_index=device_index,
            width=info.get("width"),
            height=info.get("height"),
            fps=info.get("fps"),
            backend=info.get("backend"),
            is_working=bool(info.get("is_working", False)),
            frame_captured=bool(info.get("frame_captured", False)),
            in_use=device_index in device_locks,
            in_use_by=device_locks.get(device_index)
        ))

    # Sort stable by working first then index
    webcams.sort(key=lambda d: (not d.is_working, d.device_index))
    return webcams