import logging
from typing import List, Dict

from fastapi import APIRouter, Depends, HTTPException, Request
from fastapi.responses import StreamingResponse
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from ..core.database import get_db_session, db
from ..core.security import get_current_user, get_current_user_for_stream
from ..models.database import Camera
from ..schemas import CameraCreate, CameraResponse, WebcamInfo
from ..services.camera_proxy_service import camera_proxy_service
from ..services.camera_diagnostics import camera_diagnostics

router = APIRouter(prefix="/v1", tags=["Camera Management"])
logger = logging.getLogger(__name__)


@router.get("/sites/{site_id:int}/cameras", response_model=List[CameraResponse])
async def list_cameras(
    site_id: int,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(Camera.tenant_id == user["tenant_id"], Camera.site_id == site_id)
        )
    )
    cameras = result.scalars().all()
    return cameras


@router.post("/sites/{site_id:int}/cameras", response_model=CameraResponse)
async def create_camera(
    site_id: int,
    camera: CameraCreate,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    # Validate camera configuration
    if camera.camera_type.value == "webcam":
        if camera.device_index is None:
            raise HTTPException(status_code=400, detail="device_index is required for webcam cameras")
        if camera.device_index < 0:
            raise HTTPException(status_code=400, detail="device_index must be non-negative")
        
        # Check if device_index is already in use by another camera in this tenant/site
        existing_camera_result = await db_session.execute(
            select(Camera).where(
                and_(
                    Camera.tenant_id == user["tenant_id"],
                    Camera.site_id == site_id,
                    Camera.camera_type == camera.camera_type,
                    Camera.device_index == camera.device_index
                )
            )
        )
        existing_camera = existing_camera_result.scalar_one_or_none()
        if existing_camera:
            raise HTTPException(
                status_code=400, 
                detail=f"Device index {camera.device_index} is already used by camera {existing_camera.camera_id}"
            )
    
    elif camera.camera_type.value == "rtsp":
        if not camera.rtsp_url:
            raise HTTPException(status_code=400, detail="rtsp_url is required for RTSP cameras")
        if camera.device_index is not None:
            raise HTTPException(status_code=400, detail="device_index should not be set for RTSP cameras")
    
    # camera_id will be auto-generated by the database (auto-increment bigint)
    new_camera = Camera(
        tenant_id=user["tenant_id"],
        site_id=site_id,
        name=camera.name,
        camera_type=camera.camera_type,
        rtsp_url=camera.rtsp_url,
        device_index=camera.device_index
    )
    db_session.add(new_camera)
    await db_session.commit()
    await db_session.refresh(new_camera)  # Get the auto-generated camera_id
    return new_camera


@router.get("/sites/{site_id:int}/cameras/{camera_id:int}", response_model=CameraResponse)
async def get_camera(
    site_id: int,
    camera_id: int,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    return camera


@router.put("/sites/{site_id:int}/cameras/{camera_id:int}", response_model=CameraResponse)
async def update_camera(
    site_id: int,
    camera_id: int,
    camera_update: CameraCreate,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Update camera fields
    camera.name = camera_update.name
    camera.camera_type = camera_update.camera_type
    camera.rtsp_url = camera_update.rtsp_url
    camera.device_index = camera_update.device_index
    
    await db_session.commit()
    await db_session.refresh(camera)
    return camera


@router.delete("/sites/{site_id:int}/cameras/{camera_id:int}")
async def delete_camera(
    site_id: int,
    camera_id: int,
    user: dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Stop all running jobs for this camera before deletion
    logger.info(f"Stopping all jobs for camera {camera_id} before deletion")
    
    stopped_services = []
    
    # 1. Stop camera streaming via proxy service (delegates to worker)
    try:
        if camera_proxy_service.is_camera_streaming(camera_id):
            logger.info(f"Stopping active stream for camera {camera_id} via worker")
            stop_result = await camera_proxy_service.stop_camera_stream(camera_id)
            if stop_result.get("success"):
                stopped_services.append("camera_streaming")
                logger.info(f"Successfully stopped stream for camera {camera_id}")
            else:
                logger.warning(f"Failed to stop stream for camera {camera_id}: {stop_result.get('error')}")
    except Exception as e:
        logger.warning(f"Error stopping camera stream: {e}")
    
    # 3. Future: Notify worker processes to stop processing this camera
    # When workers support dynamic camera management, this would send
    # a stop signal to any worker processes handling this camera:
    # await worker_coordinator.stop_camera_processing(camera_id_str)
    
    # 4. Future: Stop any background face recognition jobs
    # When background face recognition jobs are implemented:
    # await face_job_manager.stop_camera_jobs(camera_id_str)
    
    # Log any services that were stopped
    if stopped_services:
        logger.info(f"Stopped services for camera {camera_id}: {stopped_services}")
    
    # Now safe to delete the camera from database
    await db_session.delete(camera)
    await db_session.commit()
    
    response = {
        "message": "Camera deleted successfully", 
        "camera_id": camera_id
    }
    if stopped_services:
        response["stopped_services"] = stopped_services
        logger.info(f"Camera {camera_id} deleted after stopping services: {stopped_services}")
    
    return response


# Camera Streaming Endpoints

@router.post("/sites/{site_id:int}/cameras/{camera_id:int}/stream/start")
async def start_camera_stream(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Start streaming for a specific camera"""
    tenant_id = user["tenant_id"]
    
    # Debug logging
    logger.info(f"Starting camera stream - tenant_id: {tenant_id} (type: {type(tenant_id)}), site_id: {site_id} (type: {type(site_id)}), camera_id: {camera_id} (type: {type(camera_id)})")
    
    if not tenant_id:
        raise HTTPException(status_code=400, detail="Invalid tenant_id from token")
    
    await db.set_tenant_context(db_session, str(tenant_id))
    
    # Get camera info
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    if not camera.is_active:
        raise HTTPException(status_code=400, detail="Camera is not active")
    
    # Start streaming via proxy service (delegates to worker)
    result = await camera_proxy_service.start_camera_stream(
        camera_id=camera_id,
        camera_type=camera.camera_type.value,
        rtsp_url=camera.rtsp_url,
        device_index=camera.device_index
    )
    
    if not result.get("success"):
        raise HTTPException(
            status_code=500, 
            detail=f"Failed to start camera stream: {result.get('error', 'Unknown error')}"
        )
    
    return {
        "message": result.get("message", "Camera stream started successfully"),
        "camera_id": camera_id,
        "worker_id": result.get("worker_id"),
        "stream_active": True
    }


@router.post("/sites/{site_id:int}/cameras/{camera_id:int}/stream/stop")
async def stop_camera_stream(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Stop streaming for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Stop streaming via proxy service
    result = await camera_proxy_service.stop_camera_stream(camera_id)
    
    return {
        "message": result.get("message", "Camera stream stopped"),
        "camera_id": camera_id,
        "worker_id": result.get("worker_id"),
        "stream_active": False,
        "success": result.get("success")
    }

@router.post("/sites/{site_id:int}/cameras/{camera_id:int}/processing/start")
async def start_camera_processing(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Start face recognition processing for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    if not camera.is_active:
        raise HTTPException(status_code=400, detail="Camera is not active")
    
    # Find worker assigned to this camera
    from app.services.camera_delegation_service import camera_delegation_service
    from app.services.worker_command_service import worker_command_service
    from common.enums.commands import WorkerCommand, CommandPriority
    
    worker_id = camera_delegation_service.get_camera_worker(camera_id)
    if not worker_id:
        raise HTTPException(status_code=400, detail="No worker assigned to camera")
    
    try:
        # Send start processing command to worker
        command_id = worker_command_service.send_command(
            worker_id=worker_id,
            command=WorkerCommand.START_PROCESSING,
            parameters={"camera_id": camera_id},
            priority=CommandPriority.NORMAL,
            requested_by=user.get("sub", "system")
        )
        
        return {
            "message": "Face recognition processing started",
            "camera_id": camera_id,
            "worker_id": worker_id,
            "command_id": command_id,
            "processing_active": True
        }
        
    except Exception as e:
        logger.error(f"Error starting camera processing: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start processing: {str(e)}")


@router.post("/sites/{site_id:int}/cameras/{camera_id:int}/processing/stop")
async def stop_camera_processing(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Stop face recognition processing for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Find worker assigned to this camera
    from app.services.camera_delegation_service import camera_delegation_service
    from app.services.worker_command_service import worker_command_service
    from common.enums.commands import WorkerCommand, CommandPriority
    
    worker_id = camera_delegation_service.get_camera_worker(camera_id)
    if not worker_id:
        return {
            "message": "No worker assigned to camera",
            "camera_id": camera_id,
            "processing_active": False
        }
    
    try:
        # Send stop processing command to worker
        command_id = worker_command_service.send_command(
            worker_id=worker_id,
            command=WorkerCommand.STOP_PROCESSING,
            parameters={"camera_id": camera_id},
            priority=CommandPriority.NORMAL,
            requested_by=user.get("sub", "system")
        )
        
        return {
            "message": "Face recognition processing stopped",
            "camera_id": camera_id,
            "worker_id": worker_id,
            "command_id": command_id,
            "processing_active": False
        }
        
    except Exception as e:
        logger.error(f"Error stopping camera processing: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to stop processing: {str(e)}")


@router.get("/sites/{site_id:int}/cameras/{camera_id:int}/stream/status")
async def get_camera_stream_status(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Get streaming status for a specific camera"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    # Get stream status via proxy service
    status = await camera_proxy_service.get_camera_stream_status(camera_id)
    
    return status

@router.get("/sites/{site_id:int}/streaming/status")
async def get_site_streaming_status(
    site_id: int,
    user: Dict = Depends(get_current_user),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Get comprehensive streaming status for all cameras in a site"""
    tenant_id = user["tenant_id"]
    await db.set_tenant_context(db_session, tenant_id)
    
    # Get all cameras in the site
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id
            )
        )
    )
    cameras = result.scalars().all()
    
    streaming_status = {
        "site_id": site_id,
        "total_cameras": len(cameras),
        "cameras": [],
        "workers": {},
        "streaming_summary": {
            "total_active_streams": 0,
            "total_assigned_cameras": 0,
            "cameras_without_workers": 0,
            "workers_with_issues": 0
        }
    }
    
    # Get worker registry for worker status
    from ..services.worker_registry import worker_registry
    from ..services.camera_delegation_service import camera_delegation_service
    
    for camera in cameras:
        # Get streaming status for this camera
        camera_status = await camera_proxy_service.get_camera_stream_status(camera.camera_id)
        
        # Get worker assignment
        worker_id = camera_delegation_service.get_camera_worker(camera.camera_id)
        worker_info = worker_registry.get_worker(worker_id) if worker_id else None
        
        camera_info = {
            "camera_id": camera.camera_id,
            "camera_name": camera.name,
            "camera_type": camera.camera_type.value,
            "is_active": camera.is_active,
            "stream_active": camera_status.get("stream_active", False),
            "assigned_worker_id": worker_id,
            "worker_status": camera_status.get("worker_status", "unassigned"),
            "worker_healthy": camera_status.get("worker_healthy", False),
            "last_status_check": camera_status.get("streaming_status_updated"),
            "source": camera_status.get("source", "api_call")
        }
        
        streaming_status["cameras"].append(camera_info)
        
        # Update summary counts
        if camera_status.get("stream_active"):
            streaming_status["streaming_summary"]["total_active_streams"] += 1
        if worker_id:
            streaming_status["streaming_summary"]["total_assigned_cameras"] += 1
        else:
            streaming_status["streaming_summary"]["cameras_without_workers"] += 1
        
        # Add worker info to workers dict
        if worker_info:
            if worker_id not in streaming_status["workers"]:
                worker_streaming_info = {
                    "worker_id": worker_id,
                    "worker_name": worker_info.worker_name,
                    "hostname": worker_info.hostname,
                    "status": worker_info.status.value,
                    "is_healthy": worker_info.is_healthy,
                    "last_heartbeat": worker_info.last_heartbeat.isoformat(),
                    "assigned_cameras": [],
                    "active_camera_streams": [],
                    "total_active_streams": 0
                }
                
                # Get streaming info from worker capabilities
                if (worker_info.capabilities and 
                    "active_camera_streams" in worker_info.capabilities):
                    worker_streaming_info["active_camera_streams"] = worker_info.capabilities["active_camera_streams"]
                    worker_streaming_info["total_active_streams"] = worker_info.capabilities.get("total_active_streams", 0)
                
                streaming_status["workers"][worker_id] = worker_streaming_info
            
            # Add this camera to worker's assigned cameras list
            streaming_status["workers"][worker_id]["assigned_cameras"].append(camera.camera_id)
            
            # Check for worker issues
            if not worker_info.is_healthy or worker_info.status not in ["idle", "processing", "online"]:
                streaming_status["streaming_summary"]["workers_with_issues"] += 1
    
    return streaming_status


@router.get("/streaming/status-overview")
async def get_streaming_overview(
    user: Dict = Depends(get_current_user)
):
    """Get tenant-wide streaming status overview"""
    tenant_id = user["tenant_id"]
    
    # Get all workers for this tenant
    from ..services.worker_registry import worker_registry
    from ..services.camera_delegation_service import camera_delegation_service
    
    tenant_workers = worker_registry.list_workers(tenant_id=tenant_id)
    
    overview = {
        "tenant_id": tenant_id,
        "total_workers": len(tenant_workers),
        "workers": [],
        "camera_assignments": camera_delegation_service.list_assignments(tenant_id=tenant_id),
        "summary": {
            "healthy_workers": 0,
            "active_workers": 0,
            "total_assigned_cameras": 0,
            "total_active_streams": 0,
            "workers_with_active_streams": 0
        }
    }
    
    for worker in tenant_workers:
        worker_info = {
            "worker_id": worker.worker_id,
            "worker_name": worker.worker_name,
            "hostname": worker.hostname,
            "status": worker.status.value,
            "is_healthy": worker.is_healthy,
            "last_heartbeat": worker.last_heartbeat.isoformat(),
            "site_id": worker.site_id,
            "assigned_camera_id": worker.camera_id,
            "active_camera_streams": [],
            "total_active_streams": 0
        }
        
        # Get streaming info from worker capabilities
        if (worker.capabilities and 
            "active_camera_streams" in worker.capabilities):
            worker_info["active_camera_streams"] = worker.capabilities["active_camera_streams"]
            worker_info["total_active_streams"] = worker.capabilities.get("total_active_streams", 0)
            
            if worker_info["total_active_streams"] > 0:
                overview["summary"]["workers_with_active_streams"] += 1
                overview["summary"]["total_active_streams"] += worker_info["total_active_streams"]
        
        overview["workers"].append(worker_info)
        
        # Update summary counts
        if worker.is_healthy:
            overview["summary"]["healthy_workers"] += 1
        if worker.status in ["idle", "processing", "online"]:
            overview["summary"]["active_workers"] += 1
        if worker.camera_id:
            overview["summary"]["total_assigned_cameras"] += 1
    
    return overview

@router.get("/sites/{site_id:int}/cameras/status-stream")
async def camera_status_stream(
    site_id: int,
    request: Request,
    user: Dict = Depends(get_current_user_for_stream)
):
    """Server-Sent Events stream for real-time camera status updates"""
    from ..services.camera_status_broadcaster import camera_status_broadcaster
    
    # Convert site_id to string for broadcaster
    site_id_str = str(site_id)
    
    return await camera_status_broadcaster.stream_site_status(site_id_str, request)


@router.get("/sites/{site_id:int}/cameras/{camera_id:int}/stream/feed")
async def get_camera_stream_feed(
    site_id: int,
    camera_id: int,
    user: Dict = Depends(get_current_user_for_stream),
    db_session: AsyncSession = Depends(get_db_session)
):
    """Get live video feed for a camera (MJPEG stream)"""
    tenant_id = user["tenant_id"]
    logger.info(f"Stream feed requested for camera {camera_id} in site {site_id} by tenant {tenant_id}")
    
    await db.set_tenant_context(db_session, tenant_id)
    
    # Verify camera exists
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == tenant_id,
                Camera.site_id == site_id,
                Camera.camera_id == camera_id
            )
        )
    )
    camera = result.scalar_one_or_none()
    if not camera:
        logger.error(f"Camera {camera_id} not found for tenant {tenant_id} in site {site_id}")
        raise HTTPException(status_code=404, detail="Camera not found")
    
    logger.info(f"Camera {camera_id} found: {camera.name} (active: {camera.is_active})")
    
    # Proxy stream from worker
    try:
        logger.info(f"Starting proxy stream for camera {camera_id}")
        
        # Create an async generator wrapper that properly handles the coroutine
        async def stream_wrapper():
            async for chunk in camera_proxy_service.proxy_camera_stream(camera_id):
                yield chunk
        
        logger.info(f"Returning streaming response for camera {camera_id}")
        return StreamingResponse(
            stream_wrapper(),
            media_type="multipart/x-mixed-replace; boundary=frame"
        )
    except ValueError as e:
        logger.error(f"Camera stream proxy error for camera {camera_id}: {e}")
        raise HTTPException(status_code=404, detail=str(e))


@router.get("/streaming/debug")
async def get_streaming_debug_info(
    user: Dict = Depends(get_current_user)
):
    """Get debug information about camera proxy service and worker streaming"""
    debug_info = await camera_proxy_service.get_streaming_debug_info()
    return {
        "proxy_service_status": debug_info,
        "message": "This endpoint shows camera streaming status across all workers"
    }


@router.post("/streaming/cleanup")
async def cleanup_all_streams(
    user: Dict = Depends(get_current_user)
):
    """Force cleanup all camera assignments and notify workers (emergency use)"""
    # Clean up camera assignments
    from ..services.camera_delegation_service import camera_delegation_service
    cleanup_count = camera_delegation_service.cleanup_stale_assignments()
    
    return {
        "message": f"Cleaned up {cleanup_count} stale camera assignments",
        "cleanup_count": cleanup_count
    }

@router.post("/cameras/{camera_id:int}/stop-all-jobs")
async def stop_all_camera_jobs(
    camera_id: int,
    user: Dict = Depends(get_current_user)
):
    """Stop all running jobs (streaming, face recognition, etc.) for a specific camera"""
    stopped_services = []
    
    # Stop camera streaming via proxy service
    try:
        if camera_proxy_service.is_camera_streaming(camera_id):
            logger.info(f"Stopping stream for camera {camera_id} via worker")
            stop_result = await camera_proxy_service.stop_camera_stream(camera_id)
            if stop_result.get("success"):
                stopped_services.append("camera_streaming")
        else:
            logger.info(f"Camera {camera_id} is not currently streaming")
    except Exception as e:
        logger.error(f"Error stopping camera stream: {e}")
    
    # Clean up any stale assignments
    from ..services.camera_delegation_service import camera_delegation_service
    cleanup_count = camera_delegation_service.cleanup_stale_assignments()
    if cleanup_count > 0:
        stopped_services.append(f"cleaned_{cleanup_count}_stale_assignments")
    
    return {
        "message": f"Stopped all jobs for camera {camera_id}",
        "camera_id": camera_id,
        "stopped_services": stopped_services
    }


@router.get("/streaming/validate-devices")
async def validate_device_consistency(
    user: Dict = Depends(get_current_user)
):
    """Validate consistency between database camera device_index and actual OpenCV devices"""
    # Get all webcam cameras from all sites for this tenant
    db_session = next(get_db_session())
    await db.set_tenant_context(db_session, user["tenant_id"])
    
    result = await db_session.execute(
        select(Camera).where(
            and_(
                Camera.tenant_id == user["tenant_id"],
                Camera.camera_type == "webcam"
            )
        )
    )
    webcam_cameras = result.scalars().all()
    
    # Get available OpenCV devices
    available_devices = camera_diagnostics.enumerate_cameras()
    
    # Cross-reference
    validation_report = {
        "camera_device_mappings": [],
        "issues": [],
        "available_opencv_devices": list(available_devices.keys()),
        "cameras_using_invalid_devices": []
    }
    
    for camera in webcam_cameras:
        mapping = {
            "camera_id": camera.camera_id,
            "camera_name": camera.name,
            "site_id": camera.site_id,
            "device_index": camera.device_index,
            "device_available": camera.device_index in available_devices,
            "device_working": available_devices.get(camera.device_index, {}).get("is_working", False) if camera.device_index in available_devices else False
        }
        validation_report["camera_device_mappings"].append(mapping)
        
        if camera.device_index not in available_devices:
            validation_report["issues"].append(f"Camera {camera.camera_id} ({camera.name}) uses device_index {camera.device_index} which is not available in OpenCV enumeration")
            validation_report["cameras_using_invalid_devices"].append({
                "camera_id": camera.camera_id,
                "device_index": camera.device_index,
                "issue": "Device not found"
            })
        elif not available_devices[camera.device_index].get("is_working", False):
            validation_report["issues"].append(f"Camera {camera.camera_id} ({camera.name}) uses device_index {camera.device_index} which exists but is not working")
            validation_report["cameras_using_invalid_devices"].append({
                "camera_id": camera.camera_id,
                "device_index": camera.device_index,
                "issue": "Device not working"
            })
    
    # Check for duplicate device_index usage
    device_usage = {}
    for camera in webcam_cameras:
        if camera.device_index in device_usage:
            validation_report["issues"].append(f"Device index {camera.device_index} is used by multiple cameras: {device_usage[camera.device_index]} and {camera.camera_id}")
        else:
            device_usage[camera.device_index] = camera.camera_id
    
    validation_report["summary"] = {
        "total_webcam_cameras": len(webcam_cameras),
        "total_opencv_devices": len(available_devices),
        "working_opencv_devices": len([d for d in available_devices.values() if d.get("is_working", False)]),
        "cameras_with_issues": len(validation_report["cameras_using_invalid_devices"]),
        "total_issues": len(validation_report["issues"])
    }
    
    return validation_report


@router.get("/diagnostics/cameras")
async def run_camera_diagnostics(
    user: Dict = Depends(get_current_user)
):
    """Run comprehensive camera diagnostic tests"""
    report = camera_diagnostics.generate_full_report()
    return {
        "diagnostic_report": report,
        "message": "This endpoint tests camera enumeration and simultaneous access capabilities"
    }


@router.get("/devices/webcams", response_model=List[WebcamInfo])
async def list_available_webcams(
    user: Dict = Depends(get_current_user)
):
    """List available webcam devices on the API host with basic info and whether currently in use by streaming service."""
    # Enumerate devices using diagnostics helper
    devices = camera_diagnostics.enumerate_cameras()
    # Overlay current usage from streaming service
    device_status = streaming_service.get_device_status()
    device_locks: Dict[int, str] = device_status.get("device_locks", {}) if isinstance(device_status, dict) else {}

    webcams: List[WebcamInfo] = []
    for device_index, info in devices.items():
        webcams.append(WebcamInfo(
            device_index=device_index,
            width=info.get("width"),
            height=info.get("height"),
            fps=info.get("fps"),
            backend=info.get("backend"),
            is_working=bool(info.get("is_working", False)),
            frame_captured=bool(info.get("frame_captured", False)),
            in_use=device_index in device_locks,
            in_use_by=device_locks.get(device_index)
        ))

    # Sort stable by working first then index
    webcams.sort(key=lambda d: (not d.is_working, d.device_index))
    return webcams